// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONFIGBUF_COMIXREADER_H_
#define FLATBUFFERS_GENERATED_CONFIGBUF_COMIXREADER_H_

#include "flatbuffers/flatbuffers.h"

namespace ComixReader {

    struct Size;

    struct Config;

    FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
    private:
        uint32_t h_;
        uint32_t w_;

    public:
        Size() {
            memset(this, 0, sizeof(Size));
        }

        Size(uint32_t _h, uint32_t _w)
                : h_(flatbuffers::EndianScalar(_h)),
                  w_(flatbuffers::EndianScalar(_w)) {
        }

        uint32_t h() const {
            return flatbuffers::EndianScalar(h_);
        }

        uint32_t w() const {
            return flatbuffers::EndianScalar(w_);
        }
    };

    FLATBUFFERS_STRUCT_END(Size, 8);

    struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_IMAGESIZE = 4,
            VT_CLASSCOUNT = 6,
            VT_ANCHORSSIZE = 8,
            VT_ANCHORPERGRID = 10,
            VT_ANCHORBOXES = 12
        };

        const Size *imageSize() const {
            return GetStruct<const Size *>(VT_IMAGESIZE);
        }

        uint32_t classCount() const {
            return GetField<uint32_t>(VT_CLASSCOUNT, 0);
        }

        const Size *anchorsSize() const {
            return GetStruct<const Size *>(VT_ANCHORSSIZE);
        }

        uint32_t anchorPerGrid() const {
            return GetField<uint32_t>(VT_ANCHORPERGRID, 0);
        }

        const flatbuffers::Vector<float> *anchorBoxes() const {
            return GetPointer<const flatbuffers::Vector<float> *>(VT_ANCHORBOXES);
        }

        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyField<Size>(verifier, VT_IMAGESIZE) &&
                   VerifyField<uint32_t>(verifier, VT_CLASSCOUNT) &&
                   VerifyField<Size>(verifier, VT_ANCHORSSIZE) &&
                   VerifyField<uint32_t>(verifier, VT_ANCHORPERGRID) &&
                   VerifyOffset(verifier, VT_ANCHORBOXES) &&
                   verifier.VerifyVector(anchorBoxes()) &&
                   verifier.EndTable();
        }
    };

    struct ConfigBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;

        void add_imageSize(const Size *imageSize) {
            fbb_.AddStruct(Config::VT_IMAGESIZE, imageSize);
        }

        void add_classCount(uint32_t classCount) {
            fbb_.AddElement<uint32_t>(Config::VT_CLASSCOUNT, classCount, 0);
        }

        void add_anchorsSize(const Size *anchorsSize) {
            fbb_.AddStruct(Config::VT_ANCHORSSIZE, anchorsSize);
        }

        void add_anchorPerGrid(uint32_t anchorPerGrid) {
            fbb_.AddElement<uint32_t>(Config::VT_ANCHORPERGRID, anchorPerGrid, 0);
        }

        void add_anchorBoxes(flatbuffers::Offset<flatbuffers::Vector<float>> anchorBoxes) {
            fbb_.AddOffset(Config::VT_ANCHORBOXES, anchorBoxes);
        }

        explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }

        ConfigBuilder &operator=(const ConfigBuilder &);

        flatbuffers::Offset<Config> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Config>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Config> CreateConfig(
            flatbuffers::FlatBufferBuilder &_fbb,
            const Size *imageSize = 0,
            uint32_t classCount = 0,
            const Size *anchorsSize = 0,
            uint32_t anchorPerGrid = 0,
            flatbuffers::Offset<flatbuffers::Vector<float>> anchorBoxes = 0) {
        ConfigBuilder builder_(_fbb);
        builder_.add_anchorBoxes(anchorBoxes);
        builder_.add_anchorPerGrid(anchorPerGrid);
        builder_.add_anchorsSize(anchorsSize);
        builder_.add_classCount(classCount);
        builder_.add_imageSize(imageSize);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Config> CreateConfigDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            const Size *imageSize = 0,
            uint32_t classCount = 0,
            const Size *anchorsSize = 0,
            uint32_t anchorPerGrid = 0,
            const std::vector<float> *anchorBoxes = nullptr) {
        return ComixReader::CreateConfig(
                _fbb,
                imageSize,
                classCount,
                anchorsSize,
                anchorPerGrid,
                anchorBoxes ? _fbb.CreateVector<float>(*anchorBoxes) : 0);
    }

    inline const ComixReader::Config *GetConfig(const void *buf) {
        return flatbuffers::GetRoot<ComixReader::Config>(buf);
    }

    inline const ComixReader::Config *GetSizePrefixedConfig(const void *buf) {
        return flatbuffers::GetSizePrefixedRoot<ComixReader::Config>(buf);
    }

    inline bool VerifyConfigBuffer(
            flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<ComixReader::Config>(nullptr);
    }

    inline bool VerifySizePrefixedConfigBuffer(
            flatbuffers::Verifier &verifier) {
        return verifier.VerifySizePrefixedBuffer<ComixReader::Config>(nullptr);
    }

    inline void FinishConfigBuffer(
            flatbuffers::FlatBufferBuilder &fbb,
            flatbuffers::Offset<ComixReader::Config> root) {
        fbb.Finish(root);
    }

    inline void FinishSizePrefixedConfigBuffer(
            flatbuffers::FlatBufferBuilder &fbb,
            flatbuffers::Offset<ComixReader::Config> root) {
        fbb.FinishSizePrefixed(root);
    }

}  // namespace ComixReader

#endif  // FLATBUFFERS_GENERATED_CONFIGBUF_COMIXREADER_H_
