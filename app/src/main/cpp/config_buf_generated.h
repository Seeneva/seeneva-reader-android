// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CONFIGBUF_COMIXREADER_H_
#define FLATBUFFERS_GENERATED_CONFIGBUF_COMIXREADER_H_

#include "flatbuffers/flatbuffers.h"

namespace ComixReader {

    struct Size;

    struct Config;

    FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
    private:
        uint32_t h_;
        uint32_t w_;

    public:
        Size() {
            memset(this, 0, sizeof(Size));
        }

        Size(uint32_t _h, uint32_t _w)
                : h_(flatbuffers::EndianScalar(_h)),
                  w_(flatbuffers::EndianScalar(_w)) {
        }

        uint32_t h() const {
            return flatbuffers::EndianScalar(h_);
        }

        uint32_t w() const {
            return flatbuffers::EndianScalar(w_);
        }
    };

    FLATBUFFERS_STRUCT_END(Size, 8);

    struct Config FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
        enum {
            VT_CLASSCOUNT = 4,
            VT_TOPNDETECTION = 6,
            VT_EXPTHRESH = 8,
            VT_FINALTHRESHOLD = 10,
            VT_PROBTHRESH = 12,
            VT_NMSTHRESH = 14,
            VT_IMAGESIZE = 16,
            VT_ANCHORSSIZE = 18,
            VT_ANCHORPERGRID = 20,
            VT_ANCHORBOXES = 22
        };

        uint32_t classCount() const {
            return GetField<uint32_t>(VT_CLASSCOUNT, 0);
        }

        uint32_t topNDetection() const {
            return GetField<uint32_t>(VT_TOPNDETECTION, 0);
        }

        float expThresh() const {
            return GetField<float>(VT_EXPTHRESH, 0.0f);
        }

        float finalThreshold() const {
            return GetField<float>(VT_FINALTHRESHOLD, 0.0f);
        }

        float probThresh() const {
            return GetField<float>(VT_PROBTHRESH, 0.0f);
        }

        float nmsThresh() const {
            return GetField<float>(VT_NMSTHRESH, 0.0f);
        }

        const Size *imageSize() const {
            return GetStruct<const Size *>(VT_IMAGESIZE);
        }

        const Size *anchorsSize() const {
            return GetStruct<const Size *>(VT_ANCHORSSIZE);
        }

        uint32_t anchorPerGrid() const {
            return GetField<uint32_t>(VT_ANCHORPERGRID, 0);
        }

        const flatbuffers::Vector<float> *anchorBoxes() const {
            return GetPointer<const flatbuffers::Vector<float> *>(VT_ANCHORBOXES);
        }

        bool Verify(flatbuffers::Verifier &verifier) const {
            return VerifyTableStart(verifier) &&
                   VerifyField<uint32_t>(verifier, VT_CLASSCOUNT) &&
                   VerifyField<uint32_t>(verifier, VT_TOPNDETECTION) &&
                   VerifyField<float>(verifier, VT_EXPTHRESH) &&
                   VerifyField<float>(verifier, VT_FINALTHRESHOLD) &&
                   VerifyField<float>(verifier, VT_PROBTHRESH) &&
                   VerifyField<float>(verifier, VT_NMSTHRESH) &&
                   VerifyField<Size>(verifier, VT_IMAGESIZE) &&
                   VerifyField<Size>(verifier, VT_ANCHORSSIZE) &&
                   VerifyField<uint32_t>(verifier, VT_ANCHORPERGRID) &&
                   VerifyOffset(verifier, VT_ANCHORBOXES) &&
                   verifier.VerifyVector(anchorBoxes()) &&
                   verifier.EndTable();
        }
    };

    struct ConfigBuilder {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;

        void add_classCount(uint32_t classCount) {
            fbb_.AddElement<uint32_t>(Config::VT_CLASSCOUNT, classCount, 0);
        }

        void add_topNDetection(uint32_t topNDetection) {
            fbb_.AddElement<uint32_t>(Config::VT_TOPNDETECTION, topNDetection, 0);
        }

        void add_expThresh(float expThresh) {
            fbb_.AddElement<float>(Config::VT_EXPTHRESH, expThresh, 0.0f);
        }

        void add_finalThreshold(float finalThreshold) {
            fbb_.AddElement<float>(Config::VT_FINALTHRESHOLD, finalThreshold, 0.0f);
        }

        void add_probThresh(float probThresh) {
            fbb_.AddElement<float>(Config::VT_PROBTHRESH, probThresh, 0.0f);
        }

        void add_nmsThresh(float nmsThresh) {
            fbb_.AddElement<float>(Config::VT_NMSTHRESH, nmsThresh, 0.0f);
        }

        void add_imageSize(const Size *imageSize) {
            fbb_.AddStruct(Config::VT_IMAGESIZE, imageSize);
        }

        void add_anchorsSize(const Size *anchorsSize) {
            fbb_.AddStruct(Config::VT_ANCHORSSIZE, anchorsSize);
        }

        void add_anchorPerGrid(uint32_t anchorPerGrid) {
            fbb_.AddElement<uint32_t>(Config::VT_ANCHORPERGRID, anchorPerGrid, 0);
        }

        void add_anchorBoxes(flatbuffers::Offset<flatbuffers::Vector<float>> anchorBoxes) {
            fbb_.AddOffset(Config::VT_ANCHORBOXES, anchorBoxes);
        }

        explicit ConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
                : fbb_(_fbb) {
            start_ = fbb_.StartTable();
        }

        ConfigBuilder &operator=(const ConfigBuilder &);

        flatbuffers::Offset<Config> Finish() {
            const auto end = fbb_.EndTable(start_);
            auto o = flatbuffers::Offset<Config>(end);
            return o;
        }
    };

    inline flatbuffers::Offset<Config> CreateConfig(
            flatbuffers::FlatBufferBuilder &_fbb,
            uint32_t classCount = 0,
            uint32_t topNDetection = 0,
            float expThresh = 0.0f,
            float finalThreshold = 0.0f,
            float probThresh = 0.0f,
            float nmsThresh = 0.0f,
            const Size *imageSize = 0,
            const Size *anchorsSize = 0,
            uint32_t anchorPerGrid = 0,
            flatbuffers::Offset<flatbuffers::Vector<float>> anchorBoxes = 0) {
        ConfigBuilder builder_(_fbb);
        builder_.add_anchorBoxes(anchorBoxes);
        builder_.add_anchorPerGrid(anchorPerGrid);
        builder_.add_anchorsSize(anchorsSize);
        builder_.add_imageSize(imageSize);
        builder_.add_nmsThresh(nmsThresh);
        builder_.add_probThresh(probThresh);
        builder_.add_finalThreshold(finalThreshold);
        builder_.add_expThresh(expThresh);
        builder_.add_topNDetection(topNDetection);
        builder_.add_classCount(classCount);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Config> CreateConfigDirect(
            flatbuffers::FlatBufferBuilder &_fbb,
            uint32_t classCount = 0,
            uint32_t topNDetection = 0,
            float expThresh = 0.0f,
            float finalThreshold = 0.0f,
            float probThresh = 0.0f,
            float nmsThresh = 0.0f,
            const Size *imageSize = 0,
            const Size *anchorsSize = 0,
            uint32_t anchorPerGrid = 0,
            const std::vector<float> *anchorBoxes = nullptr) {
        return ComixReader::CreateConfig(
                _fbb,
                classCount,
                topNDetection,
                expThresh,
                finalThreshold,
                probThresh,
                nmsThresh,
                imageSize,
                anchorsSize,
                anchorPerGrid,
                anchorBoxes ? _fbb.CreateVector<float>(*anchorBoxes) : 0);
    }

    inline const ComixReader::Config *GetConfig(const void *buf) {
        return flatbuffers::GetRoot<ComixReader::Config>(buf);
    }

    inline const ComixReader::Config *GetSizePrefixedConfig(const void *buf) {
        return flatbuffers::GetSizePrefixedRoot<ComixReader::Config>(buf);
    }

    inline bool VerifyConfigBuffer(
            flatbuffers::Verifier &verifier) {
        return verifier.VerifyBuffer<ComixReader::Config>(nullptr);
    }

    inline bool VerifySizePrefixedConfigBuffer(
            flatbuffers::Verifier &verifier) {
        return verifier.VerifySizePrefixedBuffer<ComixReader::Config>(nullptr);
    }

    inline void FinishConfigBuffer(
            flatbuffers::FlatBufferBuilder &fbb,
            flatbuffers::Offset<ComixReader::Config> root) {
        fbb.Finish(root);
    }

    inline void FinishSizePrefixedConfigBuffer(
            flatbuffers::FlatBufferBuilder &fbb,
            flatbuffers::Offset<ComixReader::Config> root) {
        fbb.FinishSizePrefixed(root);
    }

}  // namespace ComixReader

#endif  // FLATBUFFERS_GENERATED_CONFIGBUF_COMIXREADER_H_
