// automatically generated by the FlatBuffers compiler, do not modify

#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

pub mod parser {
    #![allow(dead_code)]
    #![allow(unused_imports)]

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    // struct Size, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Size {
        h_: u32,
        w_: u32,
    } // pub struct Size
    impl flatbuffers::SafeSliceAccess for Size {}
    impl<'a> flatbuffers::Follow<'a> for Size {
        type Inner = &'a Size;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Size>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Size {
        type Inner = &'a Size;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Size>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Size {
        type Output = Size;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Size as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Size {
        type Output = Size;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Size as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Size {
        pub fn new<'a>(_h: u32, _w: u32) -> Self {
            Size {
                h_: _h.to_little_endian(),
                w_: _w.to_little_endian(),
            }
        }
        pub fn h<'a>(&'a self) -> u32 {
            self.h_.from_little_endian()
        }
        pub fn w<'a>(&'a self) -> u32 {
            self.w_.from_little_endian()
        }
    }

    // struct Image, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Image {
        size__: Size,
        channels_: u32,
        batchSize_: u32,
    } // pub struct Image
    impl flatbuffers::SafeSliceAccess for Image {}
    impl<'a> flatbuffers::Follow<'a> for Image {
        type Inner = &'a Image;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Image>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Image {
        type Inner = &'a Image;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Image>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Image {
        type Output = Image;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Image as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Image {
        type Output = Image;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Image as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Image {
        pub fn new<'a>(_size_: &'a Size, _channels: u32, _batchSize: u32) -> Self {
            Image {
                size__: *_size_,
                channels_: _channels.to_little_endian(),
                batchSize_: _batchSize.to_little_endian(),
            }
        }
        pub fn size_<'a>(&'a self) -> &'a Size {
            &self.size__
        }
        pub fn channels<'a>(&'a self) -> u32 {
            self.channels_.from_little_endian()
        }
        pub fn batchSize<'a>(&'a self) -> u32 {
            self.batchSize_.from_little_endian()
        }
    }

    pub enum ConfigOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Config<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Config<'a> {
        type Inner = Config<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Config<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Config { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ConfigArgs<'args>,
        ) -> flatbuffers::WIPOffset<Config<'bldr>> {
            let mut builder = ConfigBuilder::new(_fbb);
            if let Some(x) = args.anchorBoxes {
                builder.add_anchorBoxes(x);
            }
            builder.add_nmsThresh(args.nmsThresh);
            builder.add_probThresh(args.probThresh);
            builder.add_finalThreshold(args.finalThreshold);
            builder.add_expThresh(args.expThresh);
            builder.add_topNDetection(args.topNDetection);
            builder.add_classCount(args.classCount);
            builder.add_anchorPerGrid(args.anchorPerGrid);
            if let Some(x) = args.image {
                builder.add_image(x);
            }
            if let Some(x) = args.anchorsSize {
                builder.add_anchorsSize(x);
            }
            builder.finish()
        }

        pub const VT_ANCHORSSIZE: flatbuffers::VOffsetT = 4;
        pub const VT_IMAGE: flatbuffers::VOffsetT = 6;
        pub const VT_ANCHORPERGRID: flatbuffers::VOffsetT = 8;
        pub const VT_CLASSCOUNT: flatbuffers::VOffsetT = 10;
        pub const VT_TOPNDETECTION: flatbuffers::VOffsetT = 12;
        pub const VT_EXPTHRESH: flatbuffers::VOffsetT = 14;
        pub const VT_FINALTHRESHOLD: flatbuffers::VOffsetT = 16;
        pub const VT_PROBTHRESH: flatbuffers::VOffsetT = 18;
        pub const VT_NMSTHRESH: flatbuffers::VOffsetT = 20;
        pub const VT_ANCHORBOXES: flatbuffers::VOffsetT = 22;

        #[inline]
        pub fn anchorsSize(&self) -> &'a Size {
            self._tab.get::<Size>(Config::VT_ANCHORSSIZE, None).unwrap()
        }
        #[inline]
        pub fn image(&self) -> &'a Image {
            self._tab.get::<Image>(Config::VT_IMAGE, None).unwrap()
        }
        #[inline]
        pub fn anchorPerGrid(&self) -> u32 {
            self._tab
                .get::<u32>(Config::VT_ANCHORPERGRID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn classCount(&self) -> u32 {
            self._tab
                .get::<u32>(Config::VT_CLASSCOUNT, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn topNDetection(&self) -> u32 {
            self._tab
                .get::<u32>(Config::VT_TOPNDETECTION, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn expThresh(&self) -> f32 {
            self._tab
                .get::<f32>(Config::VT_EXPTHRESH, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn finalThreshold(&self) -> f32 {
            self._tab
                .get::<f32>(Config::VT_FINALTHRESHOLD, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn probThresh(&self) -> f32 {
            self._tab
                .get::<f32>(Config::VT_PROBTHRESH, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn nmsThresh(&self) -> f32 {
            self._tab
                .get::<f32>(Config::VT_NMSTHRESH, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn anchorBoxes(&self) -> flatbuffers::Vector<'a, f32> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    Config::VT_ANCHORBOXES,
                    None,
                )
                .unwrap()
        }
    }

    pub struct ConfigArgs<'a> {
        pub anchorsSize: Option<&'a Size>,
        pub image: Option<&'a Image>,
        pub anchorPerGrid: u32,
        pub classCount: u32,
        pub topNDetection: u32,
        pub expThresh: f32,
        pub finalThreshold: f32,
        pub probThresh: f32,
        pub nmsThresh: f32,
        pub anchorBoxes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    }
    impl<'a> Default for ConfigArgs<'a> {
        #[inline]
        fn default() -> Self {
            ConfigArgs {
                anchorsSize: None, // required field
                image: None,       // required field
                anchorPerGrid: 0,
                classCount: 0,
                topNDetection: 0,
                expThresh: 0.0,
                finalThreshold: 0.0,
                probThresh: 0.0,
                nmsThresh: 0.0,
                anchorBoxes: None, // required field
            }
        }
    }
    pub struct ConfigBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ConfigBuilder<'a, 'b> {
        #[inline]
        pub fn add_anchorsSize(&mut self, anchorsSize: &'b Size) {
            self.fbb_
                .push_slot_always::<&Size>(Config::VT_ANCHORSSIZE, anchorsSize);
        }
        #[inline]
        pub fn add_image(&mut self, image: &'b Image) {
            self.fbb_
                .push_slot_always::<&Image>(Config::VT_IMAGE, image);
        }
        #[inline]
        pub fn add_anchorPerGrid(&mut self, anchorPerGrid: u32) {
            self.fbb_
                .push_slot::<u32>(Config::VT_ANCHORPERGRID, anchorPerGrid, 0);
        }
        #[inline]
        pub fn add_classCount(&mut self, classCount: u32) {
            self.fbb_
                .push_slot::<u32>(Config::VT_CLASSCOUNT, classCount, 0);
        }
        #[inline]
        pub fn add_topNDetection(&mut self, topNDetection: u32) {
            self.fbb_
                .push_slot::<u32>(Config::VT_TOPNDETECTION, topNDetection, 0);
        }
        #[inline]
        pub fn add_expThresh(&mut self, expThresh: f32) {
            self.fbb_
                .push_slot::<f32>(Config::VT_EXPTHRESH, expThresh, 0.0);
        }
        #[inline]
        pub fn add_finalThreshold(&mut self, finalThreshold: f32) {
            self.fbb_
                .push_slot::<f32>(Config::VT_FINALTHRESHOLD, finalThreshold, 0.0);
        }
        #[inline]
        pub fn add_probThresh(&mut self, probThresh: f32) {
            self.fbb_
                .push_slot::<f32>(Config::VT_PROBTHRESH, probThresh, 0.0);
        }
        #[inline]
        pub fn add_nmsThresh(&mut self, nmsThresh: f32) {
            self.fbb_
                .push_slot::<f32>(Config::VT_NMSTHRESH, nmsThresh, 0.0);
        }
        #[inline]
        pub fn add_anchorBoxes(
            &mut self,
            anchorBoxes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Config::VT_ANCHORBOXES, anchorBoxes);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConfigBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ConfigBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Config<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_
                .required(o, Config::VT_ANCHORSSIZE, "anchors_size");
            self.fbb_.required(o, Config::VT_IMAGE, "image");
            self.fbb_
                .required(o, Config::VT_ANCHORBOXES, "anchor_boxes");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_config<'a>(buf: &'a [u8]) -> Config<'a> {
        flatbuffers::get_root::<Config<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_config<'a>(buf: &'a [u8]) -> Config<'a> {
        flatbuffers::get_size_prefixed_root::<Config<'a>>(buf)
    }

    #[inline]
    pub fn finish_config_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Config<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_config_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Config<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod Parser
